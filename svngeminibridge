#!/usr/bin/env ruby

#  Ruby Subversion - Gemini bridge
#  Copyright (C) 2011  Sjoerd van Leent
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.


require 'base64'
require 'digest/md5'
require 'cgi'
require 'net/http'
require 'net/https'
require 'yaml'
require 'rexml/document'
require 'date'

# This script class can used primarily for interop functionality between 
# Subversion and CounterSoft Gemini, for delivering GNU/Linux and possibly 
# other platform compatibility
#
# It uses a YAML file for loading information, typically stored in the
# hooks folder, together with this script. The YAML file should have four
# specific entries:
#
# * <tt>username</tt>: Containing the proxy username for subversion in Gemini
# * <tt>password or api</tt>: Either the password or the api key generated by 
#                             Gemini
# * <tt>url</tt>: The url of the Gemini server, accepting both http as well 
#                 as https
# * _Optional_ <tt>svn_remote_url</tt>: The remote url of subversion used 
#                                       by normal clients
#
# Within the post-hook an entry should be added similar to:
#
# <tt>"$REPOS"/hooks/svngeminibridge "$1" "$2"</tt>
#
# Make sure that the execute bit is set
#
# == Prerequisites ==
#
# * Access to the /tmp path
# * The [+svn+] command should be in the path
# * The [svngeminibridge.yaml] file should be accessible

class SVNGeminiBridge
  
  # Initializes a SVNGeminiBridge object
  #
  # config:: The configuration, which is extracted from the
  # svngeminibridge.yaml file
  # repos:: The repository name, which should be passed by SVN as first
  # command line argument
  # rev:: The revision number, which should be passed by SVN as second
  # command line argument
  def initialize(config, repos, rev)
    @repos = repos
    @svn_remote_url = @repos
    @svn_remote_url = config['svn_remote_url'] if config['svn_remote_url']
    @svn_remote_url = @svn_remote_url[0..-2] if @svn_remote_url[-1] == ?/
    @repos = @repos[0..-2] if @repos[-1] == ?/
    @svn_remote_url = File.join(@svn_remote_url, File.dirname(File.expand_path(File.dirname(__FILE__))).rpartition('/').last)
    @rev = rev.to_i
    @username = config['username']
    @encusername = Base64.encode64(@username)
    if config['password']
      @encpassword = Base64.encode64(Digest::MD5.digest(config['password']))
      @mode = :password
    else
      @encapikey = Base64.encode64(config['api'])
      @mode = :apikey
    end
    url = config['url']
    url << '/' unless url[-1].eql?('/')
    @url = URI.parse(url)
    @host = @url.host
    @port = @url.port
    @base_path = @url.path
    if @url.scheme.eql?('https')
      @ssl = true
    elsif @url.scheme.eql?('http')
      @ssl = false
    else
      raise "Unsupported URL scheme (either http or https)"
    end
  end
  
  # Starts running everything. The application flow is:
  #
  # extract comments > extract files > verify user > verify issue > 
  # get gemini files > modify gemini files
  def start
    puts "SSL     : #{@ssl}"
    puts "Base URL: #{@base_path}"
    puts "Host    : #{@host}"
    puts "Port    : #{@port}"
    
    extract_comments
    extract_files
    
    verify_user
    verify_issue
    insert_comments
    get_gemini_files
    modify_remote_files
    puts 'Exit    : Success'
  end
  
  private
  
  # Extracts comments from the repository, using a temporary file (make sure
  # /tmp is accessible and writable)
  #
  # The first GEM:<number> found indicates the issue number. If no such
  # match is found, the hook is closed. Furthermore, the author info is
  # extracted.
  def extract_comments
    f = rand(0xFFFFFFFF)
    `svn log file://#{@repos} --xml -r #{@rev} > /tmp/#{f}`   
    doc = REXML::Document.new(File.open("/tmp/#{f}", 'r'))
    `rm /tmp/#{f}`
    
    doc.elements.each('log/logentry/msg') { |msg| @msg = msg.text }
    doc.elements.each('log/logentry/author') { |author| @author = author.text }
    
    text = nil
    _, _, text = @msg.partition('GEM:') if @msg
    if text == nil or text.size == 0
      raise SystemExit.new(0)
    end
    issue, _, _ = text.partition(' ')

    if issue == nil or issue.size == 0
      raise SystemExit.new(0)
    end
    
    @issue = issue.to_i
    puts "Issue   : #{@issue}"
    puts "Message : #{@msg}"
    puts "Author  : #{@author}"
  end
  
  # Extracts the last diffs as a summary from the repository. (Make sure
  # /tmp is accessible and writable)
  def extract_files
    f = rand(0xFFFFFFFF)
    `svn diff file://#{@repos} -r #{@rev-1}:#{@rev} --xml --summarize > /tmp/#{f}`
    doc = REXML::Document.new(File.open("/tmp/#{f}", 'r'))
    `rm /tmp/#{f}`
    
    repo_path_size = "file://#{@repos}".size 
    files = []
    doc.elements.each('diff/paths') do |paths|
      paths.elements.each('path') do |path|
        action = path.attribute('item').value
        if action.size > 0
          char = ''
          # Ruby < 1.9.0 and > 1.9.2 compatibility
          if action[0].instance_of?(String)
            char = action[0].upcase # > 1.9.2
          else
            char = action[0].chr.upcase # < 1.9.0
          end
          action = "#{char.upcase}#{action[1..-1]}"
        end
        loc = path.text[repo_path_size..-1]
        loc = '.' if (loc.size == 0)
        files << {:action => action, :location => loc}
      end
    end
    @files = files
    
    for file in @files
      puts "File    : #{file[:location]} (#{file[:action]})"
    end
  end
  
  # Verifies the subversion proxy user and extracts the user id
  def verify_user
    eun = CGI::escape(@username)
    path = "api/users.ashx/users/username/#{eun}"
    res = create_http.start { |http| 
      gemini_get http, path
    }
    if !res.instance_of?(Net::HTTPOK)
      raise SystemExit.new(-1)
    end
    body = REXML::Document.new(res.body)
    body.elements.each('UserEN/UserID') {|user| @svn_user_id = user.text.to_i}
  end
  
  # Verifies the issue and extracts the project id
  def verify_issue
    ei = CGI::escape(@issue.to_s)
    path = "api/issues.ashx/issues/#{ei}"
    res = create_http.start { |http| 
      gemini_get http, path
    }
    if !res.instance_of?(Net::HTTPOK)
      raise SystemExit.new(-1)
    end
    body = REXML::Document.new(res.body)
    body.elements.each('IssueEN/ProjectID') {|p| @project_id = p.text.to_i}
  end
  
  # Get all current files stored in the gemini sourcecontrol array
  def get_gemini_files
    ei = CGI::escape(@issue.to_s)
    path = "api/issues.ashx/issues/#{ei}/sourcecontrol"
    
    res = create_http.start { |http| 
      gemini_get http, path
    }
    if !res.instance_of?(Net::HTTPOK)
      raise SystemExit.new(-1)
    end
    
    body = REXML::Document.new(res.body)
    
    @gemini_files = {}
    
    body.elements.each('ArrayOfSourceControlEN/SourceControlEN') do |scen|
      file_name = ""
      file_path = ""
      repo = ""
      id = 0
      scen.elements.each('FileName') { |fn| file_name = fn.text }
      scen.elements.each('FilePath') { |fp| file_path = fp.text }
      scen.elements.each('SourceControlRepository') { |r| repo = r.text }
      scen.elements.each('FileID') { |f| id = f.text.to_i }
      @gemini_files[id] = {
        :file_name => file_name, :file_path => file_path, :repo => repo
      }
    end
  end
  
  # Delete a specific remote file or folder from gemini (SVN only sends
  # one Deleted whenever a folder with files is removed, so this needs to be
  # executed recursively)
  def delete_remote_files_recurse(file_name, file_path)
    ei = CGI::escape(@issue.to_s)
    for key, value in @gemini_files
      found_file_name = value[:file_name]
      found_file_name = "" unless found_file_name
      found_file_path = value[:file_path]
      found_file_path = "" unless found_file_path
      found_repo = value[:repo]
      found_repo = "" unless found_repo
      if(found_file_name.strip.eql?(file_name.strip) and
         found_file_path.strip.eql?(file_path.strip) and
         found_repo.strip.eql?(@svn_remote_url.strip))
        path = "api/issues.ashx/issues/#{ei}/sourcecontrol/#{key}"
        res = create_http.start { |http| 
          gemini_delete http, path
        }
        for key2, value2 in @gemini_files
          if(value2[:file_path] and
             value2[:file_path].strip == (file_path + '/' + file_name) and
             value2[:repo] == found_repo)
            delete_remote_files_recurse(value2[:file_name], value2[:file_path])
          end
        end
      end
    end
  end
  
  # Modifies remote files either deleting them or adding/updating them
  def modify_remote_files
    for file in @files
      file_path, _, file_name = file[:location].rpartition('/')
      if file[:action].eql?("Deleted")
        delete_remote_files_recurse(file_name, file_path)
      else
        ei = CGI::escape(@issue.to_s)
        path = "api/issues.ashx/issues/#{ei}/sourcecontrol"
        data = REXML::Document.new('<?xml version="1.0" encoding="utf-8"?>')
        scen = data.add_element("SourceControlEN")
        scen.add_element("State").text = "NoChange"
        scen.add_element("DateCreated").text = DateTime.now.to_s
        scen.add_element("FileID").text = '0'
        scen.add_element("IssueID").text = @issue
        scen.add_element("FileName").text = file_name
        scen.add_element("FilePath").text = file_path
        scen.add_element("SourceControlRepository").text = "#{@svn_remote_url}"
        data = data.to_s
        res = create_http.start { |http| 
          gemini_post http, path, data
        }
      end
    end
  end
  
  # Inserts the specific comments extracted in an earlier part
  def insert_comments
    ei = CGI::escape(@issue.to_s)
    path = "api/issues.ashx/issues/#{ei}/comments"
    
    # Specify the internal document
    
    table = REXML::Document.new
    table_elem = table.add_element("table")
    table_elem.attributes['class'] = 'webForm'
    table_elem.attributes['align'] = 'center'
    table_elem.attributes['cellspacing'] = '0'
    table_elem.attributes['cellpadding'] = '5'
    table_elem.attributes['width'] = '70%'

    tr = table_elem.add_element('tr')
    td = tr.add_element('td')
    td.attributes['class'] = 'webFormButtonRow bordered'
    td.attributes['valign'] = 'top'
    td.attributes['align'] = 'center'
    td.attributes['colspan'] = '2'
    td.add_element('b').text = 'SVN Comment'
    
    # The various rows
    create_table_row(table_elem, 'Author', @author)
    create_table_row(table_elem, 'SVN Revision', @rev)
    
    if @files.size < 50
      create_table_row(table_elem, 'Affected Files', @files.collect {|f|
                         "#{@svn_remote_url}#{f[:location]} (#{f[:action]})"
                       })
    else
      create_table_row(table_elem, 'Affected Files', 'Too many files have been affected to put in the message')
    end
    create_table_row(table_elem, 'Check-in Comment', @msg)
    
    # Creating the data xml
    data = REXML::Document.new('<?xml version="1.0" encoding="utf-8"?>')
    issue_comment = data.add_element('IssueCommentEN')
    issue_comment.attributes['xmlns:xsi'] = 'http://www.w3.org/2001/XMLSchema-instance'
    issue_comment.attributes['xmlns:xsd'] = 'http://www.w3.org/2001/XMLSchema'
    issue_comment.add_element('State').text = 'NoChange'
    issue_comment.add_element('DateCreated').text = DateTime.now.to_s
    issue_comment.add_element('CommentID').text = '0'
    issue_comment.add_element('UserID').text = @svn_user_id
    issue_comment.add_element('IssueID').text = @issue
    issue_comment.add_element('ProjectID').text = @project_id
    issue_comment.add_element('Comment').text = table.to_s
    issue_comment.add_element('UserName')
    issue_comment.add_element('IsClosing').text = 'false'
    issue_comment.add_element('Visibility').text = '1'
    issue_comment.add_element('VisibilityMemberType').text = 'GlobalGroup'
    
    res = create_http.start { |http| 
      gemini_post(http, path, data.to_s)
    }
    if !res.instance_of?(Net::HTTPOK)
      raise SystemExit.new(-1)
    end
  end
  
  # Helper method for insert_comments
  def create_table_row(table_elem, key, value)
    tr = table_elem.add_element('tr')
    td = tr.add_element('td')
    td.attributes['class'] = 'webFormPrompt'
    td.attributes['valign'] = 'top'
    td.attributes['align'] = 'left'
    td.text = key
    td = tr.add_element('td')
    td.attributes['class'] = 'bordered'
    td.attributes['valign'] = 'top'
    td.attributes['align'] = 'left'
    if value.instance_of?(::Array) and !(value.instance_of?(::String))
      for v in value
        td.add_text(v)
        td.add_element("br")
      end
    else
      td.text = value      
    end
  end

  # The tokens needed for Gemini (either with password token or api token)
  def pass
    pass = {'gemini-username-token' => @encusername}
    if @mode == :password
      pass['gemini-password-token'] = @encpassword
    else
      pass['gemini-api-token'] = @encapikey
    end
    return pass
  end
  
  # Executes something a number of times if failed, after that write the message to the log
  def bomb_proof(retries)
    begin
      yield
    rescue
      retries -= 1
      retry if retries > 0
      $stderr.puts "An error occurred while sending a REST command to the Gemini Application Server"
    end
  end
  
  # A generalisation for request_get together with the proper tokens
  def gemini_get(http, path)
    bomb_proof 3 do
      puts "Rq      : #{path}"
      http.request_get(File.join(@base_path, path), pass)
    end
  end

  # A generalisation for request(Delete.new) together with the proper tokens
  def gemini_delete(http, path)
    bomb_proof 3 do
      puts "Rm      : #{path}"
      http.request(Net::HTTP::Delete.new(File.join(@base_path, path), pass))
    end
  end

  # A generalisation for request_post together with the proper tokens
  def gemini_post(http, path, data)
    bomb_proof 3 do
      puts "Tx      : #{path}"
      p = pass
      p['content-type'] = 'text/xml' 
      http.request_post(File.join(@base_path, path), data, p)
    end
  end
  
  
  # Creates a generic HTTP object for every request
  def create_http
    http = Net::HTTP.new(@host, @port)
    http.use_ssl = @ssl
    return http
  end

end

# Initializes the application
config = YAML.load_file(File.join(File.dirname(__FILE__), 'svngeminibridge.yaml'))

if ARGV.length != 2
  puts "Usage: $REPOS/hooks/svngeminibridge $REPOS $REV"
else
SVNGeminiBridge.new(config, ARGV[0], ARGV[1]).start
end

